# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s7_Mp8WTJiO7nX446WiDoHq1KJOUhkkS
"""

import torch
import torchvision.transforms as transforms
from PIL import Image
import requests
from io import BytesIO

# Load a pre-trained model for object detection (e.g., ResNet-50)
model = torch.hub.load('pytorch/vision', 'resnet50', pretrained=True)
model.eval()

# Define the transformation to preprocess the image
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

def predict_blindness(image_path):
    image = Image.open(image_path)
    input_tensor = transform(image)
    input_batch = input_tensor.unsqueeze(0)

    # If you have a GPU, move the input and model to GPU for faster inference
    if torch.cuda.is_available():
        input_batch = input_batch.to('cuda')
        model.to('cuda')

    with torch.no_grad():
        output = model(input_batch)

    # Get the index of the predicted class (assuming binary classification)
    predicted_index = output.argmax().item()

    # Replace this line with your specific class labels if needed
    class_labels = ["Non-blind", "Blind"]
    predicted_class = class_labels[predicted_index]

    return predicted_class

# Example usage with an image from a URL
url = 'https://example.com/image.jpg'  # Replace with your image URL
response = requests.get(url)
image = Image.open(BytesIO(response.content))

predicted_class = predict_blindness(image)

print("Predicted class:", predicted_class)